# Sets ls to always color directories.
ls() { ls --color=auto "$@"; }

# Short-form for Docker Compose. Overwrites built-in dc command.
dc() { docker compose "$@"; }

# Short-forms for common git operations.
g() { git "$@"; }
ga() { git add "$@"; }
gb() { git branch "$@"; }
gc() { git commit "$@"; }
gca() { git add . && git commit "$@"; }
gch() { git checkout "$@"; }
gchm() { git checkout $(git_main_branch) "$@"; }
gl() { git log --oneline "$@"; }
gpl() { git pull  "$@"; }
gplom() { git pull origin $(git_main_branch) "$@"; }
gps() { git push "$@"; }
gpsu() { git push -u origin $(git_current_branch) "$@"; }
grh() { git reset --hard origin/$(git_current_branch) "$@"; }
gs() { git -c color.ui=always status -sb | $HOME/util-scripts/sort-git-status.py "$@"; }

# Utilities for git management of dotfiles.
dotfiles() { GIT_DIR="$HOME/dotfiles" GIT_WORK_TREE="$HOME" "$@"; }
dotfiles-ls() { dotfiles git ls-tree main -r --name-only; }

# Echoes main/master branch depending on repo.
git_main_branch() {
    command git rev-parse --git-dir &>/dev/null || return
    local ref
    for ref in refs/{heads,remotes/{origin,upstream}}/{main,trunk}; do
        if command git show-ref -q --verify $ref; then
            echo ${ref:t}
            return
        fi
    done
    echo master
}

# Echoes the current git branch.
git_current_branch() {
    local ref
    ref=$(GIT_OPTIONAL_LOCKS=0 command git symbolic-ref --quiet HEAD 2> /dev/null)
    local ret=$?
    if [[ $ret != 0 ]]; then
        [[ $ret == 128 ]] && return  # No git repo.
        ref=$(GIT_OPTIONAL_LOCKS=0 command git rev-parse --short HEAD 2> /dev/null) || return
    fi
    echo ${ref#refs/heads/}
}

# Enters Python virtual environment in provided path.
venv() {
    venv_path="venv/bin/activate"
    if [ ${#} -eq 0 ]
    then
        source ${venv_path}
    else
        target_dir="${1}"
        previous_dir=$(pwd)
        cd ${target_dir} && source ${venv_path}
        cd ${previous_dir}
    fi
}

# Auto-detects Node version on directory change.
enter_directory() {
    if [[ ${PWD} == ${PREV_PWD} ]]; then
        return
    fi

    if [[ "${PWD}" =~ "${PREV_PWD}" && ! -f ".nvmrc" ]]; then
        return
    fi

    PREV_PWD=${PWD}
    if [[ -f ".nvmrc" ]]; then
        nvm use
        NVM_DIRTY=true
    elif [[ ${NVM_DIRTY} = true ]]; then
        nvm use default
        NVM_DIRTY=false
    fi
}
export PROMPT_COMMAND=enter_directory
